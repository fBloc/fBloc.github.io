---
sidebar_position: 3
---
# 调度

## 当前的工作流执行是如何调度的？
目前实现的调度方式是function级别并且广度优先的。这样实现是为了更高的并行度。

使用以下假设进行说明：
  - 工作流A：其开始节点下面同层有3个函数函数 - x、y、z（表示其可以并行运行），而x下游还有个函数节点u（表示必须要x运行完成后u才能开始运行）。
  - 每个函数都一样的需要运行60秒
  - 前后间隔只1秒的情况下，工作流A被连续的触发了两次运行。假设第一次触发的运行叫运行1、1秒后触发的叫运行2
接下来看看有不同client消费实例部署数量时候的表现：
  - 假设只部署了1个client消费实例
    - 由于调度方式是function级别的、运行1到达时，调度发现x、y、z是能够同时触发的，并就同时触发了x、y、z，假设其运行分别是x1、y1、z1
    - 此时由于只有一个消费实例，其可能消费到x1、y1、z1中的任意一个、其余两个将进行排队（这里我们假设消费了x1，也即是y1、z1会进行排队）
    - 此时到达了1秒后，运行2到达。同理，调度发现x、y、z是能够同时触发的，并就同时触发了x、y、z，假设其运行分别是x2、y2、z2。但是由于y1和z1还在排队、故x2、y2、z2会排队到y1和z1的后面
    - 这时问题就出现了，当60秒后、x1运行完，调度会发现x下的u函数需要调度运行，故发布了运行u1，那么u1的排队排到了x2、y2、z2之后！
    - ...
    - 总的说来，运行1的四个函数执行总共运行耗时361秒，因为u1的运行需要等待x2、y2、z2都运行完毕后才会进行
  - 假设部署了6个client消费实例
    - 由于调度方式是function级别的、运行1到达时，调度发现x、y、z是能够同时触发的，并就同时触发了x、y、z，假设其运行分别是x1、y1、z1
    - 此时有6消费实例，其中3个会同时分别消费到x1、y1、z1中的一个并运行（并行）
    - 此时到达了1秒后，运行2到达。同理，调度发现x、y、z是能够同时触发的，并就同时触发了x、y、z，假设其运行分别是x2、y2、z2。同理剩下的3个消费实例会同时分别消费到x2、y2、z2中的一个并运行（并行）
    - 当60秒后、x1运行完，调度会发现x下的u函数需要调度运行，故发布了运行u1，此时由于x1运行已完、肯定y1和z1也运行完了 -> 空闲3个消费实例，故u1会直接被执行
    - ...
    - 总的说来，运行1的四个函数执行总共运行耗时61秒、运行2的四个函数而总共耗时61秒，且两次运行的重叠时间有60秒

通过上面的例子我主要想说明的是：你需要了解bloc的调度特征，从而部署合适的消费实例 以及 根据运行特征进行决定是否要开启禁止并行运行的功能（开启后、上面的运行2触发时、由于运行1是执行中状态，故运行2会被拦截）

## 如何保证错误重试？
基于rabbit本身的 `auto-ack` 特性，采用手动ack方式，从而如果运行中途退出的话，会重新消费到消息

## 一个工作流里支持跨仓库跨语言的function是如何实现的？
具体的来说是：每个client都会有个client_name，而调度器在发布运行消息时，会将此client_name作为topic字段的一部分。从而保证了此function的运行消息、只会被拥有此function的client部署实例消费到。此过程是通过rabbitMQ实现的，从而与接受者是哪个代码仓库或者什么编程语言没有关系。client实例接收到信息后、通过function_id字段从自己拥有的functions中匹配此id，找到后就可以进行运行了。